/* CLU GENERATED */
/* All structures and functions generated by CLU start with clug */
/*
Typical Usage:

    clugMyKernelName s = clugCreate_MyKernelName(0);
    clu_enqueue_params params = CLU_DEFAULT_PARAMS;
    params.nd_range = CLU_ND1(bufferLength);
    status = clugEnqueue_MyKernel(s, &params, ...);

Exports:

    clug_vectorAdd clugCreate_vectorAdd(cl_int*)
    cl_int clugEnqueue_vectorAdd(...)
*/

#include <clu.h>
#ifndef __CPPVectorAddKernel_cl_h
#define __CPPVectorAddKernel_cl_h

/* This function is shared by all clugCreate_* functions below */
INLINE cl_program clugGet_CPPVectorAddKernel_cl_h(cl_int* out_pStatus)
{
    static const char* src[1] = {
    /* 1*/ "kernel void vectorAdd(global const int *inputA, global const int *inputB, global int *output)\n"
    /* 2*/ "{\n"
    /* 3*/ "	output[get_global_id(0)] = inputA[get_global_id(0)] + inputB[get_global_id(0)];\n"
    /* 4*/ "}\n",
    };
    /* CLU will only build this program the first time */
    /* CLU will release this program upon shutdown (cluRelease) */
    cl_program program = cluBuildSourceArray(1, src, "CLU_GENERATED_BUILD", out_pStatus);
    return program;
}

/* object that associates specific cl_kernel with its wrapper code */
typedef struct _clug_vectorAdd
{
    cl_kernel  m_kernel;  /* application should clReleaseKernel */
    cl_program m_program; /* DO NOT clReleaseProgram */
} clug_vectorAdd;

/* function to initialize structure and create kernel from source */
INLINE clug_vectorAdd clugCreate_vectorAdd(cl_int * errcode_ret)
{
    cl_int status;
    clug_vectorAdd s;
    s.m_program = clugGet_CPPVectorAddKernel_cl_h(&status);
    if (CL_SUCCESS == status)
    {
        s.m_kernel = clCreateKernel(s.m_program, "vectorAdd", &status);
    }
    if (errcode_ret)
    {
        *errcode_ret = status;
    }
    return s;
}

INLINE cl_int clugEnqueue_vectorAdd(clug_vectorAdd s, clu_enqueue_params* params, cl_mem inputA, cl_mem inputB, cl_mem output)
{
    cl_uint status = CL_SUCCESS;
    status = clSetKernelArg(s.m_kernel, 0, sizeof(cl_mem), &inputA);
    if (CL_SUCCESS != status) return status;
    status = clSetKernelArg(s.m_kernel, 1, sizeof(cl_mem), &inputB);
    if (CL_SUCCESS != status) return status;
    status = clSetKernelArg(s.m_kernel, 2, sizeof(cl_mem), &output);
    if (CL_SUCCESS != status) return status;
    status = cluEnqueue(s.m_kernel, params);
    return status;
}

#endif

